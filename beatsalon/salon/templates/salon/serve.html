{% extends 'base.html'%}
{% load staticfiles %}
{% block contents %}
<h2>{{info.title}}</h2>

<div id="myModal" class="modal">

  <!-- Modal content -->
  <div class="modal-content">
    <img class="close" src="{% static 'blog/X.png' %}">
    <div class = "row">
      <div class="left_1">
        <form action="#" class="form-inline" >
                <input type="text" id="search" placeholder="Type something..." autocomplete="off" class="form-control" size="60px">
                <input type="image" id="question" src="{% static 'blog/?.png' %}" alt="Submit">
         </form>
         <div id="serve"></div>
         <table id="results"></table>
    </div>
</div>
</div>
</div>

<script>
function Lines(r,g,b){
  var op;
  this.r=r;
  this.g=g;
  this.b=b;
  this.history=[];

  var numOfPoints=30;
  var lengthBetweenPoints;
  var heightOfPoints=[];

  var smoothFactor=1;
  var sum=[];
  var newFreq=[];

  for (var i=0;i<numOfPoints;i++){
    sum[i]=0;
    newFreq[i]=0;
    heightOfPoints[i]=0;
  }

  for(var i=0;i<numOfPoints;i++){
      this.history[i]=[];
    }

  this.display=function(){
    lengthBetweenPoints = (windowWidth-100)/numOfPoints;

    var freq = fft.analyze();
    var range = freq.length/numOfPoints; //1024/30

    ///smoothing effect - may be unnecessary
//     for (var k=0;k<numOfPoints;k++){
//       newFreq[k] = fft.getEnergy(range*k+1, range*k+range);
//       sum[k]+=(newFreq[k]-sum[k])*smoothFactor;
//       heightOfPoints[k] = sum[k];
//       // this.y = heightOfPoints[k];
// }
    var col= color(this.r,this.g,this.b,op);
    stroke(col);
    strokeWeight(2);
    noFill();
    // fill(255,1);
    ellipse(50,windowHeight/2,3,3);
    ellipse(windowWidth-50, windowHeight/2,3,3);

    beginShape();
    vertex(50,windowHeight/2);
    curveVertex(50,windowHeight/2);
    for(var i=0; i<numOfPoints;i++){
      heightOfPoints[i] = map(fft.getEnergy(range*i+1, range*i+range),0,255,0,windowHeight*0.8);
      curveVertex(i*lengthBetweenPoints+50, heightOfPoints[i]);
      this.history[i].push(heightOfPoints[i]);
    }
    curveVertex(windowWidth-50, windowHeight/2);
    vertex(windowWidth-50, windowHeight/2);
    endShape();

    for (var i=0;i<numOfPoints;i++){
      if (this.history[i].length>1){
        this.history[i].splice(0,1);
      }
      for (var j=0; j<this.history[i].length;j++){
        op=50*j+10;
        col= color(this.r,this.g,this.b,op);
        stroke(col);
        beginShape();
        vertex(50,windowHeight/2);
        curveVertex(50,windowHeight/2);
        for(var k=0; k<numOfPoints;k++){
          curveVertex(k*lengthBetweenPoints+50, this.history[k][j]);
        }
        curveVertex(windowWidth-50, windowHeight/2);
        vertex(windowWidth-50, windowHeight/2);
        endShape();
      }
    }
  }
}
</script>
<script>
var song, amplitude;
var fft;
var musicPlaying = true;

var beatHoldFrames=20;
//what amplitude level can trigger a beat
var beatThreshold = 0.4;
//when we have a beat, beatcutoff will be reset to 1.1*beatTreshold and then decay
var beatCutOff=0;
var beatDecayRate=0.98;
var countFramesSinceLastBeat=0;

var drawParticle = false;
var numOfPoints=30;
var r,g,b;
var lines=[];

function preload() {
  song = loadSound({% with 'data/'|add:info.title|add:'.mp3' as music_static %}"{% static music_static %}"{% endwith %})
}

function setup() {
  createCanvas(windowWidth, windowHeight);
  song.play();
  amplitude = new p5.Amplitude();
  amplitude.setInput(song);
  amplitude.smooth(0.9);

  fft = new p5.FFT();
  fft.setInput(song);
  smooth(1);
  r=255;
  g=255;
  b=255;
  lines.push(new Lines(r,g,b));
}

function draw() {
  background(20);
  var amp = amplitude.getLevel();

  detectBeat(amp);
  r=random(255);
  g=random(255);
  b=random(255);
  if (drawParticle==true){
    lines.push(new Lines(r,g,b));
  }
  if (lines.length>4){
    lines.splice(0,1);
  }
  for (var i=0; i<lines.length;i++){
    lines[i].display();
  }

}

function detectBeat(level){
  if(level>beatCutOff && level>beatThreshold){
    backgroundColor = color(random(255),random(255),random(255));
    drawParticle = true;
    beatCutOff = level*1.2;
    countFramesSinceLastBeat=0;
  }
  else{
    drawParticle=false;
    if(countFramesSinceLastBeat <= beatHoldFrames){
      countFramesSinceLastBeat++;

    }
    else{
      beatCutOff *= beatDecayRate;
      beatCutOff = Math.max(beatCutOff,beatThreshold);

    }
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  background(0);
}

function keyPressed(){
  if (keyCode ==32){
    if (musicPlaying){
      song.pause();
      musicPlaying=false;
    }
    else{
      song.play();
      musicPlaying=true;
    }
  }
}
</script>

{% endblock %}
